<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Container</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
            background: #b1b1b1;
        }
        h1 { color: black; text-align: center; position: absolute; top: 0px; width: 100%; z-index: 2; /* Set a higher z-index for the title text */ }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <h1 id="titleText">Click on the board to play. White turn </h1>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        //set initial piece locations
        const dict = new Map([
            // Black pieces
            ['0,0', 'black rook'],
            ['1,0', 'black knight'],
            ['2,0', 'black bishop'],
            ['3,0', 'black queen'],
            ['4,0', 'black king'],
            ['5,0', 'black bishop'],
            ['6,0', 'black knight'],
            ['7,0', 'black rook'],
            ['0,1', 'black pawn'],
            ['1,1', 'black pawn'],
            ['2,1', 'black pawn'],
            ['3,1', 'black pawn'],
            ['4,1', 'black pawn'],
            ['5,1', 'black pawn'],
            ['6,1', 'black pawn'],
            ['7,1', 'black pawn'],

            // White pieces
            ['0,7', 'white rook'],
            ['1,7', 'white knight'],
            ['2,7', 'white bishop'],
            ['3,7', 'white queen'],
            ['4,7', 'white king'],
            ['5,7', 'white bishop'],
            ['6,7', 'white knight'],
            ['7,7', 'white rook'],
            ['0,6', 'white pawn'],
            ['1,6', 'white pawn'],
            ['2,6', 'white pawn'],
            ['3,6', 'white pawn'],
            ['4,6', 'white pawn'],
            ['5,6', 'white pawn'],
            ['6,6', 'white pawn'],
            ['7,6', 'white pawn']
        ]);


        // Set the canvas size to fill the window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Padding around the square
        const padding = 60;

        // Calculate the size of the square based on the smaller dimension of the window
        const squareSize = Math.min(canvas.width, canvas.height) - 2 * padding;

        // Rectangle that contains chess board
        const rect = {
            x: (canvas.width - squareSize) / 2,
            y: (canvas.height - squareSize) / 2,
            width: squareSize,
            height: squareSize,
            color: '#e6e6e6'
        };


        class Square {
            constructor(chessX, chessY, x, y, size, color, piece) {
                this.chessX = chessX;
                this.chessY = chessY;
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.originalColor = color;
                this.clickedColor = 'yellow';
                this.clicked = false;
                this.piece = piece;
                this.svgImage = new Image();
            }

            draw(context) {

                
                context.fillStyle = this.originalColor;
                context.fillRect(this.x, this.y, this.size, this.size);

                if (this.clicked) {
                    context.globalAlpha = 0.4;
                    context.fillStyle = 'black'
                    context.fillRect(this.x, this.y, this.size, this.size);
                    context.globalAlpha = 1;
                }


                if (this.piece) {

                    if (this.piece == 'black rook' ) {
                        this.svgImage.src = './images/monarchy/bR.svg'
                    } else if (this.piece == 'black pawn' ) {
                        this.svgImage.src = './images/monarchy/bP.svg'
                    } else if (this.piece == 'black queen' ) {
                        this.svgImage.src = './images/monarchy/bQ.svg'
                    } else if (this.piece == 'black king' ) {
                        this.svgImage.src = './images/monarchy/bK.svg'
                    } else if (this.piece == 'black bishop' ) {
                        this.svgImage.src = './images/monarchy/bB.svg'
                    } else if (this.piece == 'black knight' ) {
                        this.svgImage.src = './images/monarchy/bN.svg'
                    } else if (this.piece == 'white rook' ) {
                        this.svgImage.src = './images/monarchy/wR.svg'
                    } else if (this.piece == 'white pawn' ) {
                        this.svgImage.src = './images/monarchy/wP.svg'
                    } else if (this.piece == 'white queen' ) {
                        this.svgImage.src = './images/monarchy/wQ.svg'
                    } else if (this.piece == 'white king' ) {
                        this.svgImage.src = './images/monarchy/wK.svg'
                    } else if (this.piece == 'white bishop' ) {
                        this.svgImage.src = './images/monarchy/wB.svg'
                    } else if (this.piece == 'white knight' ) {
                        this.svgImage.src = './images/monarchy/wN.svg'
                    }

                    if (this.svgImage.complete) { 
                        context.drawImage(this.svgImage, this.x, this.y, this.size, this.size); 
                    } else { 
                        this.svgImage.onload = () => { context.drawImage(this.svgImage, this.x, this.y, this.size, this.size); }; 
                    }
                }

            }

            isPointInside(x, y) {
                return x >= this.x && x <= this.x + this.size && y >= this.y && y <= this.y + this.size;
            }

            toggleColor() {
                this.clicked = !this.clicked;
            }
        }

        // Create an array of squares
        const squares = [];
        const numSquares = 5;




        
        
        let placeSquare = false;
        context.fillStyle = 'grey';

        for (let jumpY = 0; jumpY < 8; jumpY++) {
            for (let jumpX = 0; jumpX < 8; jumpX++) {
                const piece = dict.get(`${jumpX},${jumpY}`) ? dict.get(`${jumpX},${jumpY}`) : ''
                if (placeSquare) {
                    newSquare = new Square(jumpX, jumpY, rect.x+jumpX*rect.height/8, rect.y+jumpY*rect.width/8, rect.width/8, 'grey',piece)
                } else {
                    newSquare = new Square(jumpX, jumpY, rect.x+jumpX*rect.height/8, rect.y+jumpY*rect.width/8, rect.width/8, 'white',piece);
                }

                dict.set(`${jumpX},${jumpY}`, newSquare)
                squares.push(newSquare);
                


                placeSquare = !placeSquare;
            }
            placeSquare = !placeSquare;
        }

        let clickedSquare = null
        let clickedSquare2 = null
        let nextSquareList = []
        let whiteTurn = true;
        canvas.addEventListener('click', (event) => {

            
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            let whiteKing = false;
            let blackKing = false
            squares.forEach(square => {
                document.getElementById('titleText').textContent = whiteTurn ? 'White turn' : 'Black turn' 
                if (square.piece == 'white king'){
                    whiteKing = true
                } else if (square.piece == 'black king'){
                    whiteKing = true
                }
                if (square.isPointInside(mouseX, mouseY)) {
                    if (clickedSquare && clickedSquare.clicked == true) {
                        clickedSquare.toggleColor();
                    }
                    for (let j = 0; j < nextSquareList.length; j++) {
                            nextSquareList[j].clicked = false
                        }



                    
                    if ((square.piece == 'white pawn' && whiteTurn) | (square.piece == 'black pawn' && !whiteTurn)) {
                        square.clicked = true;
                        clickedSquare = square
                        let enemy = whiteTurn ? 'black' : 'white'
                        let direction = whiteTurn ? -1: 1;
                        
                        let nearEnemy = false;

                        if (dict.get(`${square.chessX-1},${square.chessY+direction}`) && dict.get(`${square.chessX-1},${square.chessY+direction}`).piece.includes(enemy)) {
                            clickedSquare2 = dict.get(`${square.chessX-1},${square.chessY+direction}`)
                            clickedSquare2.clicked = true;
                            nextSquareList.push(clickedSquare2)
                            let nearEnemy = true;
                        }
                        if (dict.get(`${square.chessX+1},${square.chessY+direction}`) && dict.get(`${square.chessX+1},${square.chessY+direction}`).piece.includes(enemy)) {
                            clickedSquare2 = dict.get(`${square.chessX+1},${square.chessY+direction}`)
                            clickedSquare2.clicked = true;
                            nextSquareList.push(clickedSquare2)
                            let nearEnemy = true;
                        }
                        else if (dict.get(`${square.chessX},${square.chessY+direction}`) && !nearEnemy){
                            clickedSquare2 = dict.get(`${square.chessX},${square.chessY+direction}`)
                            clickedSquare2.clicked = true;
                            nextSquareList.push(clickedSquare2)
                        }

                        
                    } else if ((square.piece == 'white rook' && whiteTurn) | (square.piece == 'black rook' && !whiteTurn)) {
                        square.clicked = true;
                        let friend = whiteTurn ? 'white' : 'black'
                        clickedSquare = square
                    

                        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                        directions.forEach(xyAdd => {
                            let [xAdd, yAdd] = xyAdd;
                            let validNext = true;
                            let nextSquare = square; 

                            while (validNext) {
                                nextSquare = dict.get(`${nextSquare.chessX + xAdd},${nextSquare.chessY + yAdd}`);
                                if (nextSquare) {
                                    if (nextSquare.piece != '') {
                                        validNext = false;
                                    }

                                    nextSquare.clicked = nextSquare.piece.includes(friend) ? false : true;
                                    nextSquareList.push(nextSquare);
                                } else {
                                    validNext = false;
                                }
                            }
                        });

                    } else if ((square.piece == 'white bishop' && whiteTurn) | (square.piece == 'black bishop' && !whiteTurn)) {
                        square.clicked = true;
                        clickedSquare = square
                        let friend = whiteTurn ? 'white' : 'black'
                        

                        const directions = [[1, 1], [-1, -1], [1, -1], [-1, 1]];
                        directions.forEach(xyAdd => {
                            let [xAdd, yAdd] = xyAdd;
                            let validNext = true;
                            let nextSquare = square; 

                            while (validNext) {
                                nextSquare = dict.get(`${nextSquare.chessX + xAdd},${nextSquare.chessY + yAdd}`);
                                if (nextSquare) {
                                    if (nextSquare.piece != '') {
                                        validNext = false;
                                    }

                                    nextSquare.clicked = nextSquare.piece.includes(friend) ? false : true;
                                    nextSquareList.push(nextSquare);
                                } else {
                                    validNext = false;
                                }
                            }
                        });
                    } else if ((square.piece == 'white queen' && whiteTurn) | (square.piece == 'black queen' && !whiteTurn)) {
                        square.clicked = true;
                        clickedSquare = square
                        let friend = whiteTurn ? 'white' : 'black'
                        

                        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, -1], [1, -1], [-1, 1]];
                        directions.forEach(xyAdd => {
                            let [xAdd, yAdd] = xyAdd;
                            let validNext = true;
                            let nextSquare = square; 

                            while (validNext) {
                                nextSquare = dict.get(`${nextSquare.chessX + xAdd},${nextSquare.chessY + yAdd}`);
                                if (nextSquare) {
                                    if (nextSquare.piece != '') {
                                        validNext = false;
                                    }

                                    nextSquare.clicked = nextSquare.piece.includes(friend) ? false : true;
                                    nextSquareList.push(nextSquare);
                                } else {
                                    validNext = false;
                                }
                            }
                        });
                    } else if ((square.piece == 'white king' && whiteTurn) | (square.piece == 'black king' && !whiteTurn)) {
                        square.clicked = true;
                        clickedSquare = square
                        let friend = whiteTurn ? 'white' : 'black'
                        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [-1, -1], [1, -1], [-1, 1]];
                        directions.forEach(xyAdd => {
                            let [xAdd, yAdd] = xyAdd;
                            let nextSquare = square; 
                            nextSquare = dict.get(`${nextSquare.chessX + xAdd},${nextSquare.chessY + yAdd}`);
                            if (nextSquare) {
                                if (nextSquare.piece != '') {
                                }
                                nextSquare.clicked = nextSquare.piece.includes(friend) ? false : true;
                                nextSquareList.push(nextSquare);
                            }
                        });
                    } else if ((square.piece == 'white knight' && whiteTurn) | (square.piece == 'black knight' && !whiteTurn)) {
                        square.clicked = true;
                        clickedSquare = square
                        let friend = whiteTurn ? 'white' : 'black'
                        const directions = [[-1,2], [1,2], [2,1] , [2,-1], [1, -2], [-1,-2], [-2,1], [-2,-1]];
                        
                        directions.forEach(xyAdd => {
                            let [xAdd, yAdd] = xyAdd;
                            let nextSquare = square; 
                            nextSquare = dict.get(`${nextSquare.chessX + xAdd},${nextSquare.chessY + yAdd}`);
                            if (nextSquare) {
                                if (nextSquare.piece != '') {
                                }
                                nextSquare.clicked = nextSquare.piece.includes(friend) ? false : true;
                                nextSquareList.push(nextSquare);
                            }
                        });  
                    } else {

                        
                        for (let i = 0; i < nextSquareList.length; i++) {
                            if (square == nextSquareList[i]) {
                                square.piece = clickedSquare.piece
                                if (square.piece.includes('white')){
                                    whiteTurn = false;
                                } else {
                                    whiteTurn = true;
                                }
                                clickedSquare.piece = ''
                                nextSquareList = []


                                break;

                            }
                            
                        }

                        

                    }
                    

                        
                }
            });

        });
        // Game loop
        function gameLoop() {
            // Clear the canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the board
            context.fillStyle = rect.color;
            context.fillRect(rect.x, rect.y, rect.width, rect.height);


            //draw the smaller squares
            let blackKing = false;
            let whiteKing = false;
            squares.forEach(square => {
                square.draw(context)
                if (square.piece == 'white king') {
                    whiteKing = true
                }
                if (square.piece == 'black king') {
                    blackKing = true
                }
            }); 


            if (!blackKing) {
                document.getElementById('titleText').textContent = 'White side wins'
                return;
            }
            if (!whiteKing) {
                document.getElementById('titleText').textContent = 'Black side wins'
                return;
            }

            // Request the next frame
            requestAnimationFrame(gameLoop);

        }

        // Start the game loop
        gameLoop();
    </script>
</body>
</html>
